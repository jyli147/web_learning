# Флесы
Flexbox состоит из гибкого контейнера (flex container) и гибких элементов (flex items). Гибкие элементы могут выстраиваться в строку или столбик, а оставшееся свободное пространство распределяется между ними различными способами.
* Код для установки флекс контейнеров
.flex-container {
/*генерирует flex-контейнер уровня блока*/
 display: -webkit-flex; 
display: flex; 
}
.flex-container {
/*генерирует flex-контейнер уровня строки*/
 display: -webkit-inline-flex;
 display: inline-flex; }
## 1. Свойство **flex-direction**
1. row	Значение по умолчанию, слева направо (в rtl справа налево). Flex-элементы выкладываются в строку. Начало (main-start) и конец (main-end) направления главной оси соответствуют началу (inline-start) и концу (inline-end) оси строки (inline-axis).
2. row-reverse	Направление справа налево (в rtl слева направо). Flex-элементы выкладываются в строку относительно правого края контейнера (в rtl — левого).
3. column	Направление сверху вниз. Flex-элементы выкладываются в колонку.
4. column-reverse	Колонка с элементами в обратном порядке, снизу вверх.
5. initial	Устанавливает значение свойства в значение по умолчанию.
6. inherit	Наследует значение свойства от родительского элемента.
## Управление многострочностью flex-контейнера: flex-wrap
1. nowrap	Значение по умолчанию. Flex-элементы не переносятся, а располагаются в одну линию слева направо (в rtl справа налево).
2. wrap	Flex-элементы переносятся, располагаясь в несколько горизонтальных рядов (если не помещаются в один ряд) в направлении слева направо (в rtl справа налево).
3. wrap-reverse	Flex-элементы переносятся на новые линии, располагаясь в обратном порядке слева-направо, при этом перенос происходит снизу вверх.
4. initial	Устанавливает значение свойства в значение по умолчанию.
5. inherit	Наследует значение свойства от родительского элемента.
## Имеется свойство, которое обьединяет многострочность и направление flex-flow, для этого нужно обьединить вышесказанные теги. Пример:
flex-flow: row;
flex-flow: row-reverse;
flex-flow: column;
flex-flow: column-reverse;
flex-flow: nowrap;
flex-flow: wrap;
flex-flow: wrap-reverse;
flex-flow: row nowrap;
flex-flow: column wrap;
flex-flow: column-reverse wrap-reverse;
flex-flow: inherit;
flex-flow: initial;
## Можно менять порядок отображения эментов свойство order.
Пример: 
1. order: 2;
2. order: -1;
Так же можно выбрать определенные столбюец и поставить его в начало или конец. article:nth-of-type(3) №- это значит какой флекс контейнер мфы берем для разработки.
##  Коэффициент роста: flex-grow
## Коэффициент сжатия: flex-shrink
## Базовый размер: flex-basis em, px
## Выравнивание по главной оси: justify-content
1. flex-start	Значение по умолчанию. Flex-элементы выкладываются в направлении, идущем от начала flex-контейнера.
2. flex-end	Flex-элементы размещаются в конце flex-контейнера.
3. center	Flex-элементы выравниваются по центру flex-контейнера.
4. space-between	Flex-элементы равномерно распределяются по линии. Первый flex-элемент помещается вровень с краем начальной линии, последний flex-элемент — вровень с краем конечной линии, а остальные flex-элементы на линии распределяются так, чтобы расстояние между любыми двумя соседними элементами было одинаковым. Если оставшееся свободное пространство отрицательно или в строке присутствует только один flex-элемент, это значение идентично параметру flex-start.
5. space-around	Flex-элементы на линии распределяются так, чтобы расстояние между любыми двумя смежными flex-элементами было одинаковым, а расстояние между первым / последним flex-элементами и краями flex-контейнера составляло половину от расстояния между flex-элементами.
6. initial	Устанавливает значение свойства в значение по умолчанию.
7. inherit	Наследует значение свойства от родительского элемента.
## Выравнивание по поперечной оси и высоте
###  align-items по поперечной оси
1. flex-start	Верхний край flex-элемента помещается вплотную с flex-линией (или на расстоянии, с учетом заданных полей margin и рамок border элемента), проходящей через начало поперечной оси.
2. flex-end	Нижний край flex-элемента помещается вплотную с flex-линией (или на расстоянии, с учетом заданных полей margin и рамок border элемента), проходящей через конец поперечной оси.
3. center	Поля flex-элемента центрируется по поперечной оси в пределах flex-линии.
4. baseline	Базовые линии всех flex-элементов, участвующих в выравнивании, совпадают.
5. stretch	Если поперечный размер flex-элемента вычисляется как auto и ни одно из поперечных значений margin не равно auto, элемент растягивается. Значение по умолчанию.
6. initial	Устанавливает значение свойства в значение по умолчанию.
7. inherit	Наследует значение свойства от родительского элемента.
### align-self по высоте
1. auto	Значение по умолчанию. Flex-элемент использует выравнивание, указанное в свойстве align-items flex-контейнера.
2. flex-start	Верхний край flex-элемента помещается вплотную с flex-линией (или на расстоянии, с учетом заданных полей margin и рамок border элемента), проходящей через начало поперечной оси.
3. flex-end	Нижний край flex-элемента помещается вплотную с flex-линией (или на расстоянии, с учетом заданных полей margin и рамок border элемента), проходящей через конец поперечной оси.
4. center	Поля flex-элемента центрируется по поперечной оси в пределах flex-линии.
5. baseline	Flex-элемент выравнивается по базовой линии.
stretch	Если поперечный размер flex-элемента вычисляется как auto и ни одно из поперечных значений margin не равно auto, элемент растягивается. Значение по умолчанию.
6. initial	Устанавливает значение свойства в значение по умолчанию.
7. inherit	Наследует значение свойства от родительского элемента.
## Выравнивание строк flex-контейнера: align-content
1. flex-start	Строки укладываются по направлению к началу flex-контейнера. Край первой строки помещается вплотную к краю flex-контейнера, каждая последующая — вплотную к предыдущей строке.
2. flex-end	Строки укладываются по направлению к концу flex-контейнера. Край последней строки помещается вплотную к краю flex-контейнера, каждая предыдущая — вплотную к последующей строке.
3. center	Строки укладываются по направлению к центру flex-контейнера. Строки расположены вплотную друг к другу и выровнены по центру flex-контейнера с равным расстоянием между начальным краем содержимого flex-контейнера и первой строкой и между конечным краем содержимого flex-контейнера и последней строкой.
4. space-between	Строки равномерно распределены в flex-контейнере. Если оставшееся свободное пространство отрицательно или в flex-контейнере имеется только одна flex-линия, это значение идентично flex-start. В противном случае край первой строки помещается вплотную к начальному краю содержимого flex-контейнера, край последней строки — вплотную к конечному краю содержимого flex-контейнера. Остальные строки распределены так, чтобы расстояние между любыми двумя соседними строками было одинаковым.
5. space-around	Строки равномерно распределены в flex-контейнере с половинным пробелом на обоих концах. Если оставшееся свободное пространство отрицательно, это значение идентично центcenter. В противном случае строки распределяются таким образом, чтобы расстояние между любыми двумя соседними строками было одинаковым, а расстояние между первой / последней строками и краями содержимого flex-контейнера составляло половину от расстояния между строками.
6. stretch	Значение по умолчанию. Строки flex-элементов равномерно растягиваются, заполняя все доступное пространство. Если оставшееся свободное пространство отрицательно, это значение идентично flex-start. В противном случае свободное пространство будет разделено поровну между всеми строками, увеличивая их поперечный размер.
7. initial	Устанавливает значение свойства в значение по умолчанию.
8. inherit	Наследует значение свойства от родительского элемента.

# JS
"use strict" - строгий режим
# Переменные 
## Мы можем объявить переменные для хранения данных с помощью ключевых слов var, let или const.

1. let – это современный способ объявления.
2. var – это устаревший способ объявления. Обычно мы вообще не используем его, но мы рассмотрим тонкие отличия от let в главе Устаревшее ключевое слово "var" на случай, если это всё-таки вам понадобится.
3. const – похоже на let, но значение переменной не может изменяться.
Переменные должны быть названы таким образом, чтобы мы могли легко понять, что у них внутри.
 8 основных типов данных.

# Семь из них называют «примитивными» типами данных:
number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null для неизвестных значений – отдельный тип, имеющий одно значение null.
undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
symbol для уникальных идентификаторов.
И один не является «примитивным» и стоит особняком:
object для более сложных структур данных.
Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

Имеет две формы: typeof x или typeof(x).
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

# 3 функции браузера для взаимодействия с пользователем:

1. alert
показывает сообщение.
2. prompt
показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.
3. confirm
показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.
# Примеры:
let age = prompt('Сколько тебе лет?', 100);
alert(`Тебе ${age} лет!`); // Тебе 100 лет!

let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); // true, если нажата OK

# Логические операторы:

|| (ИЛИ)
||= (Оператор логического присваивания ИЛИ)
&& (И)
&&= (Оператор логического присваивания И)
! (НЕ)
?? (Оператор нулевого слияния)
??= (Оператор нулевого присваивания)
# Функции 
Объявление функции имеет вид:

function имя(параметры, через, запятую) {
  /* тело, код функции */
}
Передаваемые значения копируются в параметры функции и становятся локальными переменными.
Функции имеют доступ к внешним переменным. Но это работает только изнутри наружу. Код вне функции не имеет доступа к её локальным переменным.
Функция может возвращать значение. Если этого не происходит, тогда результат равен undefined.
Для того, чтобы сделать код более чистым и понятным, рекомендуется использовать локальные переменные и параметры функций, не пользоваться внешними переменными.

Функция, которая получает параметры, работает с ними и затем возвращает результат, гораздо понятнее функции, вызываемой без параметров, но изменяющей внешние переменные, что чревато побочными эффектами.

## Именование функций:

Имя функции должно понятно и чётко отражать, что она делает. Увидев её вызов в коде, вы должны тут же понимать, что она делает, и что возвращает.
Функция – это действие, поэтому её имя обычно является глаголом.
Есть много общепринятых префиксов, таких как: create…, show…, get…, check… и т.д. Пользуйтесь ими как подсказками, поясняющими, что делает функция.
#showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (получая его каким-то образом)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false


















### Header

* 1
* 2
* 3

```css
.class {
    background-color: red
}
```


[def]: https://www.example.com/image.jpg